from langchain import PromptTemplate
from langchain.chains import QAGenerationChain
from langchain.chat_models import AzureChatOpenAI

from src.prompt_templates import MULTI_QA_GPT35_PROMPT_TEMPLATE

DOC = """sd
// SPDX-License-Identifier: GPL-2.0\n/*\n *
 linux/fs/ext4/ioctl.c\n *\n * Copyright (C) 1993, 1994, 1995\n * 
 Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n */\n\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/quotaops.h>\n#include <linux/random.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/iversion.h>\n#include <linux/fileattr.h>\n#include <linux/uuid.h>\n#include "ext4_jbd2.h"\n#include "ext4.h"\n#include <linux/fsmap.h>\n#include "fsmap.h"\n#include <trace/events/ext4.h>\n\ntypedef void ext4_update_sb_callback(struct ext4_super_block *es,\n\t\t\t\t       const void *arg);\n\n/*\n * Superblock modification callback function for changing file system\n * label\n */\nstatic void ext4_sb_setlabel(struct ext4_super_block *es, const void *arg)\n{\n\t/* Sanity check, this should never happen */\n\tBUILD_BUG_ON(sizeof(es->s_volume_name) < EXT4_LABEL_MAX);\n\n\tmemcpy(es->s_volume_name, (char *)arg, EXT4_LABEL_MAX);\n}\n\n/*\n * Superblock modification callback function for changing file system\n * UUID.\n */\nstatic void ext4_sb_setuuid(struct ext4_super_block *es, const void *arg)\n{\n\tmemcpy(es->s_uuid, (__u8 *)arg, UUID_SIZE);\n}\n\nstatic\nint ext4_update_primary_sb(struct super_block *sb, handle_t *handle,\n\t\t\t   ext4_update_sb_callback func,\n\t\t\t   const void *arg)\n{\n\tint err = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct buffer_head *bh = sbi->s_sbh;\n\tstruct ext4_super_block *es = sbi->s_es;\n\n\ttrace_ext4_update_sb(sb, bh->b_blocknr, 1);\n\n\tBUFFER_TRACE(bh, "get_write_access");\n\terr = ext4_journal_get_write_access(handle, sb,\n\t\t\t\t\t    bh,\n\t\t\t\t\t    EXT4_JTR_NONE);\n\tif (err)\n\t\tgoto out_err;\n\n\tlock_buffer(bh);\n\tfunc(es, arg);\n\text4_superblock_csum_set(sb);\n\tunlock_buffer(bh);\n\n\tif (buffer_write_io_error(bh) || !buffer_uptodate(bh)) {\n\t\text4_msg(sbi->s_sb, KERN_ERR, "previous I/O error to "\n\t\t\t "superblock detected");\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = sync_dirty_buffer(bh);\nout_err:\n\text4_std_error(sb, err);\n\treturn err;\n}\n\n/*\n * Update one backup superblock in the group \'grp\' using the callback\n * function \'func\' and argument \'arg\'. If the handle is NULL the\n * modification is not journalled.\n *\n * Returns: 0 when no modification was done (no superblock in the group)\n *\t    1 when the modification was successful\n *\t   <0 on error\n */\nstatic int ext4_update_backup_sb(struct super_block *sb,\n\t\t\t\t handle_t *handle, ext4_group_t grp,\n\t\t\t\t ext4_update_sb_callback func, const void *arg)\n{\n\tint err = 0;\n\text4_fsblk_t sb_block;\n\tstruct buffer_head *bh;\n\tunsigned long offset = 0;\n\tstruct ext4_super_block *es;\n\n\tif (!ext4_bg_has_super(sb, grp))\n\t\treturn 0;\n\n\t/*\n\t * For the group 0 there is always 1k padding, so we have\n\t * either adjust offset, or sb_block depending on blocksize\n\t */\n\tif (grp == 0) {\n\t\tsb_block = 1 * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(sb_block, sb->s_blocksize);\n\t} else {\n\t\tsb_block = ext4_group_first_block_no(sb, grp);\n\t\toffset = 0;\n\t}\n\n\ttrace_ext4_update_sb(sb, sb_block, handle ? 1 : 0);\n\n\tbh = ext4_sb_bread(sb, sb_block, 0);\n\tif (IS_ERR(bh))\n\t\treturn PTR_ERR(bh);\n\n\tif (handle) {\n\t\tBUFFER_TRACE(bh, "get_write_access");\n\t\terr = ext4_journal_get_write_access(handle, sb,\n\t\t\t\t\t\t    bh,\n\t\t\t\t\t\t    EXT4_JTR_NONE);\n\t\tif (err)\n\t\t\tgoto out_bh;\n\t}\n\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tlock_buffer(bh);\n\tif (ext4_has_metadata_csum(sb) &&\n\t    es->s_checksum != ext4_superblock_csum(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, "Invalid checksum for backup "\n\t\t"superblock %llu", sb_block);\n\t\tunlock_buffer(bh);\n\t\tgoto out_bh;\n\t}\n\tfunc(es, arg);\n\tif (ext4_has_metadata_csum(sb))\n\t\tes->s_checksum = ext4_superblock_csum(sb, es);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\tif (handle) {\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bh);\n\t\tif (err)\n\t\t\tgoto out_bh;\n\t} else {\n\t\tBUFFER_TRACE(bh, "marking dirty");\n\t\tmark_buffer_dirty(bh);\n\t}\n\terr = sync_dirty_buffer(bh);\n\nout_bh:\n\tbrelse(bh);\n\text4_std_error(sb, err);\n\treturn (err) ? err : 1;\n}\n\n/*\n * Update primary and backup superblocks using the provided function\n * func and argument arg.\n *\n * Only the primary superblock and at most two backup superblock\n * modifications are journalled; the rest is modified without journal.\n * This is safe because e2fsck will re-write them if there is a problem,\n * and we\'re very unlikely to ever need more than two backups.\n */\nstatic\nint ext4_update_superblocks_fn(struct super_block *sb,\n\t\t\t       ext4_update_sb_callback func,\n\t\t\t       const void *arg)\n{\n\thandle_t *handle;\n\text4_group_t ngroups;\n\tunsigned int three = 1;\n\tunsigned int five = 5;\n\tunsigned int seven = 7;\n\tint err = 0, ret, i;\n\text4_group_t grp, primary_grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * We can\'t update superblocks while the online resize is running\n\t */\n\tif (test_and_set_bit_lock(EXT4_FLAGS_RESIZING,\n\t\t\t\t  &sbi->s_ext4_flags)) {\n\t\text4_msg(sb, KERN_ERR, "Can\'t modify superblock while"\n\t\t\t "performing online resize");\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * We\'re only going to update primary superblock and two\n\t * backup superblocks in this transaction.\n\t */\n\thandle = ext4_journal_start_sb(sb, EXT4_HT_MISC, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\t/* Update primary superblock */\n\terr = ext4_update_primary_sb(sb, handle, func, arg);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, "Failed to update primary "\n\t\t\t "superblock");\n\t\tgoto out_journal;\n\t}\n\n\tprimary_grp = ext4_get_group_number(sb, sbi->s_sbh->b_blocknr);\n\tngroups = ext4_get_groups_count(sb);\n\n\t/*\n\t * Update backup superblocks. We have to start from group 0\n\t * because it might not be where the primary superblock is\n\t * if the fs is mounted with -o sb=<backup_sb_block>\n\t */\n\ti = 0;\n\tgrp = 0;\n\twhile (grp < ngroups) {\n\t\t/* Skip primary superblock */\n\t\tif (grp == primary_grp)\n\t\t\tgoto next_grp;\n\n\t\tret = ext4_update_backup_sb(sb, handle, grp, func, arg);\n\t\tif (ret < 0) {\n\t\t\t/* Ignore bad checksum; try to update next sb */\n\t\t\tif (ret == -EFSBADCRC)\n\t\t\t\tgoto next_grp;\n\t\t\terr = ret;\n\t\t\tgoto out_journal;\n\t\t}\n\n\t\ti += ret;\n\t\tif (handle && i > 1) {\n\t\t\t/*\n\t\t\t * We\'re only journalling primary superblock and\n\t\t\t * two backup superblocks; the rest is not\n\t\t\t * journalled.\n\t\t\t */\n\t\t\terr = ext4_journal_stop(handle);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\thandle = NULL;\n\t\t}\nnext_grp:\n\t\tgrp = ext4_list_backups(sb, &three, &five, &seven);\n\t}\n\nout_journal:\n\tif (handle) {\n\t\tret = ext4_journal_stop(handle);\n\t\tif (ret && !err)\n\t\t\terr = ret;\n\t}\nout:\n\tclear_bit_unlock(EXT4_FLAGS_RESIZING, &sbi->s_ext4_flags);\n\tsmp_mb__after_atomic();\n\treturn err ? err : 0;\n}\n\n/*\n * Swap memory between @a and @b for @len bytes.\n *\n * @a:          pointer to first memory area\n * @b:          pointer to second memory area\n * @len:        number of bytes to swap\n *\n */\nstatic void memswap(void *a, void *b, size_t len)\n{\n\tunsigned char *ap, *bp;\n\n\tap = (unsigned char *)a;\n\tbp = (unsigned char *)b;\n\twhile (len-- > 0) {\n\t\tswap(*ap, *bp);\n\t\tap++;\n\t\tbp++;\n\t}\n}\n\n/*\n * Swap i_data and associated attributes between @inode1 and @inode2.\n * This function is used for the primary swap between inode1 and inode2\n * and also to revert this primary swap in case of errors.\n *\n * Therefore you have to make sure, that calling this method twice\n * will revert all changes.\n *\n * @inode1:     pointer to first inode\n * @inode2:     pointer to second inode\n */\nstatic void swap_inode_data(struct inode *inode1, struct inode *inode2)\n{\n\tloff_t isize;\n\tstruct ext4_inode_info *ei1;\n\tstruct ext4_inode_info *ei2;\n\tunsigned long tmp;\n\n\tei1 = EXT4_I(inode1);\n\tei2 = EXT4_I(inode2);\n\n\tswap(inode1->i_version, inode2->i_version);\n\tswap(inode1->i_atime, inode2->i_atime);\n\tswap(inode1->i_mtime, inode2->i_mtime);\n\n\tmemswap(ei1->i_data, ei2->i_data, sizeof(ei1->i_data));\n\ttmp = ei1->i_flags & EXT4_FL_SHOULD_SWAP;\n\tei1->i_flags = (ei2->i_flags & EXT4_FL_SHOULD_SWAP) |\n\t\t(ei1->i_flags & ~EXT4_FL_SHOULD_SWAP);\n\tei2->i_flags = tmp | (ei2->i_flags & ~EXT4_FL_SHOULD_SWAP);\n\tswap(ei1->i_disksize, ei2->i_disksize);\n\text4_es_remove_extent(inode1, 0, EXT_MAX_BLOCKS);\n\text4_es_remove_extent(inode2, 0, EXT_MAX_BLOCKS);\n\n\tisize = i_size_read(inode1);\n\ti_size_write(inode1, i_size_read(inode2));\n\ti_size_write(inode2, isize);\n}\n\nvoid ext4_reset_inode_seed(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t__le32 gen = cpu_to_le32(inode->i_generation);\n\t__u32 csum;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum, sizeof(inum));\n\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen, sizeof(gen));\n}\n\n/*\n * Swap the information from the given @inode and the inode\n * EXT4_BOOT_LOADER_INO. It will basically swap i_data and all other\n * important fields of the inodes.\n *\n * @sb:         the super block of the filesystem\n * @idmap:\tidmap of the mount the inode was found from\n * @inode:      the inode to swap with EXT4_BOOT_LOADER_INO\n *\n */\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct mnt_idmap *idmap,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tqsize_t size, size_bl, diff;\n\tblkcnt_t blocks;\n\tunsigned short bytes;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO,\n\t\t\tEXT4_IGET_SPECIAL | EXT4_IGET_BAD);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode) ||\n\t    IS_SWAPFILE(inode) || IS_ENCRYPTED(inode) ||\n\t    (EXT4_I(inode)->i_flags & EXT4_JOURNAL_DATA_FL) ||\n\t    ext4_has_inline_data(inode)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\tif (IS_RDONLY(inode) || IS_APPEND(inode) || IS_IMMUTABLE(inode) ||\n\t    !inode_owner_or_capable(idmap, inode) ||\n\t    !capable(CAP_SYS_ADMIN)) {\n\t\terr = -EPERM;\n\t\tgoto journal_err_out;\n\t}\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\terr = filemap_write_and_wait(inode->i_mapping);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = filemap_write_and_wait(inode_bl->i_mapping);\n\tif (err)\n\t\tgoto err_out;\n\n\t/* Wait for all existing dio workers */\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_SWAP_BOOT, handle);\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (is_bad_inode(inode_bl) || !S_ISREG(inode_bl->i_mode)) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_set_iversion(inode_bl, 1);\n\t\ti_size_write(inode_bl, 0);\n\t\tEXT4_I(inode_bl)->i_disksize = inode_bl->i_size;\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (ext4_has_feature_extents(sb)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto err_out1;\n\n\tsize = (qsize_t)(inode->i_blocks) * (1 << 9) + inode->i_bytes;\n\tsize_bl = (qsize_t)(inode_bl->i_blocks) * (1 << 9) + inode_bl->i_bytes;\n\tdiff = size - size_bl;\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = current_time(inode);\n\tinode_inc_iversion(inode);\n\n\tinode->i_generation = get_random_u32();\n\tinode_bl->i_generation = get_random_u32();\n\text4_reset_inode_seed(inode);\n\text4_reset_inode_seed(inode_bl);\n\n\text4_discard_preallocations(inode, 0);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\t/* No need to update quota information. */\n\t\text4_warning(inode->i_sb,\n\t\t\t"couldn\'t mark inode #%lu dirty (err %d)",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tgoto err_out1;\n\t}\n\n\tblocks = inode_bl->i_blocks;\n\tbytes = inode_bl->i_bytes;\n\tinode_bl->i_blocks = inode->i_blocks;\n\tinode_bl->i_bytes = inode->i_bytes;\n\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\tif (err < 0) {\n\t\t/* No need to update quota information. */\n\t\text4_warning(inode_bl->i_sb,\n\t\t\t"couldn\'t mark inode #%lu dirty (err %d)",\n\t\t\tinode_bl->i_ino, err);\n\t\tgoto revert;\n\t}\n\n\t/* Bootloader inode should not be counted into quota information. */\n\tif (diff > 0)\n\t\tdquot_free_space(inode, diff);\n\telse\n\t\terr = dquot_alloc_space(inode, -1 * diff);\n\n\tif (err < 0) {\nrevert:\n\t\t/* Revert all changes: */\n\t\tinode_bl->i_blocks = blocks;\n\t\tinode_bl->i_bytes = bytes;\n\t\tswap_inode_data(inode, inode_bl);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\text4_mark_inode_dirty(handle, inode_bl);\n\t}\n\nerr_out1:\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\nerr_out:\n\tfilemap_invalidate_unlock(inode->i_mapping);\njournal_err_out:\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}\n\n/*\n * If immutable is set and we are not clearing it, we\'re not allowed to change\n * anything else in the inode.  Don\'t error out if we\'re only trying to set\n * immutable on an immutable file.\n */\nstatic int ext4_ioctl_check_immutable(struct inode *inode, __u32 new_projid,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int oldflags = ei->i_flags;\n\n\tif (!(oldflags & EXT4_IMMUTABLE_FL) || !(flags & EXT4_IMMUTABLE_FL))\n\t\treturn 0;\n\n\tif ((oldflags & ~EXT4_IMMUTABLE_FL) != (flags & ~EXT4_IMMUTABLE_FL))\n\t\treturn -EPERM;\n\tif (ext4_has_feature_project(inode->i_sb) &&\n\t    __kprojid_val(ei->i_projid) != new_projid)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic void ext4_dax_dontcache(struct inode *inode, unsigned int flags)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tif (test_opt2(inode->i_sb, DAX_NEVER) ||\n\t    test_opt(inode->i_sb, DAX_ALWAYS))\n\t\treturn;\n\n\tif ((ei->i_flags ^ flags) & EXT4_DAX_FL)\n\t\td_mark_dontcache(inode);\n}\n\nstatic bool dax_compatible(struct inode *inode, unsigned int oldflags,\n\t\t\t   unsigned int flags)\n{\n\t/* Allow the DAX flag to be changed on inline directories */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags &= ~EXT4_INLINE_DATA_FL;\n\t\toldflags &= ~EXT4_INLINE_DATA_FL;\n\t}\n\n\tif (flags & EXT4_DAX_FL) {\n\t\tif ((oldflags & EXT4_DAX_MUT_EXCL) ||\n\t\t     ext4_test_inode_state(inode,\n\t\t\t\t\t  EXT4_STATE_VERITY_IN_PROGRESS)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ((flags & EXT4_DAX_MUT_EXCL) && (oldflags & EXT4_DAX_FL))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int ext4_ioctl_setflags(struct inode *inode,\n\t\t\t       unsigned int flags)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle = NULL;\n\tint err = -EPERM, migrate = 0;\n\tstruct ext4_iloc iloc;\n\tunsigned int oldflags, mask, i;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/* Is it quota file? Do not allow user to mess with it */\n\tif (ext4_is_quota_file(inode))\n\t\tgoto flags_out;\n\n\toldflags = ei->i_flags;\n\t/*\n\t * The JOURNAL_DATA flag can only be changed by\n\t * the relevant capability.\n\t */\n\tif ((flags ^ oldflags) & (EXT4_JOURNAL_DATA_FL)) {\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\tgoto flags_out;\n\t}\n\n\tif (!dax_compatible(inode, oldflags, flags)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto flags_out;\n\t}\n\n\tif ((flags ^ oldflags) & EXT4_EXTENTS_FL)\n\t\tmigrate = 1;\n\n\tif ((flags ^ oldflags) & EXT4_CASEFOLD_FL) {\n\t\tif (!ext4_has_feature_casefold(sb)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto flags_out;\n\t\t}\n\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\terr = -ENOTDIR;\n\t\t\tgoto flags_out;\n\t\t}\n\n\t\tif (!ext4_empty_dir(inode)) {\n\t\t\terr = -ENOTEMPTY;\n\t\t\tgoto flags_out;\n\t\t}\n\t}\n\n\t/*\n\t * Wait for all pending directio and then flush all the dirty pages\n\t * for this file.  The flush marks all the pages readonly, so any\n\t * subsequent attempt to write to the file (particularly mmap pages)\n\t * will come through the filesystem and fail.\n\t */\n\tif (S_ISREG(inode->i_mode) && !IS_IMMUTABLE(inode) &&\n\t    (flags & EXT4_IMMUTABLE_FL)) {\n\t\tinode_dio_wait(inode);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\t}\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto flags_out;\n\t}\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto flags_err;\n\n\text4_dax_dontcache(inode, flags);\n\n\tfor (i = 0, mask = 1; i < 32; i++, mask <<= 1) {\n\t\tif (!(mask & EXT4_FL_USER_MODIFIABLE))\n\t\t\tcontinue;\n\t\t/* These flags get special treatment later */\n\t\tif (mask == EXT4_JOURNAL_DATA_FL || mask == EXT4_EXTENTS_FL)\n\t\t\tcontinue;\n\t\tif (mask & flags)\n\t\t\text4_set_inode_flag(inode, i);\n\t\telse\n\t\t\text4_clear_inode_flag(inode, i);\n\t}\n\n\text4_set_inode_flags(inode, false);\n\n\tinode->i_ctime = current_time(inode);\n\tinode_inc_iversion(inode);\n\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\text4_journal_stop(handle);\n\tif (err)\n\t\tgoto flags_out;\n\n\tif ((flags ^ oldflags) & (EXT4_JOURNAL_DATA_FL)) {\n\t\t/*\n\t\t * Changes to the journaling mode can cause unsafe changes to\n\t\t * S_DAX if the inode is DAX\n\t\t */\n\t\tif (IS_DAX(inode)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto flags_out;\n\t\t}\n\n\t\terr = ext4_change_inode_journal_flag(inode,\n\t\t\t\t\t\t     flags & EXT4_JOURNAL_DATA_FL);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\t}\n\tif (migrate) {\n\t\tif (flags & EXT4_EXTENTS_FL)\n\t\t\terr = ext4_ext_migrate(inode);\n\t\telse\n\t\t\terr = ext4_ind_migrate(inode);\n\t}\n\nflags_out:\n\treturn err;\n}\n\n#ifdef CONFIG_QUOTA\nstatic int ext4_ioctl_setproject(struct inode *inode, __u32 projid)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint err, rc;\n\thandle_t *handle;\n\tkprojid_t kprojid;\n\tstruct ext4_iloc iloc;\n\tstruct ext4_inode *raw_inode;\n\tstruct dquot *transfer_to[MAXQUOTAS] = { };\n\n\tif (!ext4_has_feature_project(sb)) {\n\t\tif (projid != EXT4_DEF_PROJID)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (EXT4_INODE_SIZE(sb) <= EXT4_GOOD_OLD_INODE_SIZE)\n\t\treturn -EOPNOTSUPP;\n\n\tkprojid = make_kprojid(&init_user_ns, (projid_t)projid);\n\n\tif (projid_eq(kprojid, EXT4_I(inode)->i_projid))\n\t\treturn 0;\n\n\terr = -EPERM;\n\t/* Is it quota file? Do not allow user to mess with it */\n\tif (ext4_is_quota_file(inode))\n\t\treturn err;\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\treturn err;\n\n\terr = ext4_get_inode_loc(inode, &iloc);\n\tif (err)\n\t\treturn err;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\tif (!EXT4_FITS_IN_INODE(raw_inode, ei, i_projid)) {\n\t\terr = ext4_expand_extra_isize(inode,\n\t\t\t\t\t      EXT4_SB(sb)->s_want_extra_isize,\n\t\t\t\t\t      &iloc);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tbrelse(iloc.bh);\n\t}\n\n\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\tEXT4_QUOTA_INIT_BLOCKS(sb) +\n\t\tEXT4_QUOTA_DEL_BLOCKS(sb) + 3);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_stop;\n\n\ttransfer_to[PRJQUOTA] = dqget(sb, make_kqid_projid(kprojid));\n\tif (!IS_ERR(transfer_to[PRJQUOTA])) {\n\n\t\t/* __dquot_transfer() calls back ext4_get_inode_usage() which\n\t\t * counts xattr inode references.\n\t\t */\n\t\tdown_read(&EXT4_I(inode)->xattr_sem);\n\t\terr = __dquot_transfer(inode, transfer_to);\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tdqput(transfer_to[PRJQUOTA]);\n\t\tif (err)\n\t\t\tgoto out_dirty;\n\t}\n\n\tEXT4_I(inode)->i_projid = kprojid;\n\tinode->i_ctime = current_time(inode);\n\tinode_inc_iversion(inode);\nout_dirty:\n\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\tif (!err)\n\t\terr = rc;\nout_stop:\n\text4_journal_stop(handle);\n\treturn err;\n}\n#else\nstatic int ext4_ioctl_setproject(struct inode *inode, __u32 projid)\n{\n\tif (projid != EXT4_DEF_PROJID)\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n#endif\n\nint ext4_force_shutdown(struct super_block *sb, u32 flags)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint ret;\n\n\tif (flags > EXT4_GOING_FLAGS_NOLOGFLUSH)\n\t\treturn -EINVAL;\n\n\tif (ext4_forced_shutdown(sbi))\n\t\treturn 0;\n\n\text4_msg(sb, KERN_ALERT, "shut down requested (%d)", flags);\n\ttrace_ext4_shutdown(sb, flags);\n\n\tswitch (flags) {\n\tcase EXT4_GOING_FLAGS_DEFAULT:\n\t\tret = freeze_bdev(sb->s_bdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_bit(EXT4_FLAGS_SHUTDOWN, &sbi->s_ext4_flags);\n\t\tthaw_bdev(sb->s_bdev);\n\t\tbreak;\n\tcase EXT4_GOING_FLAGS_LOGFLUSH:\n\t\tset_bit(EXT4_FLAGS_SHUTDOWN, &sbi->s_ext4_flags);\n\t\tif (sbi->s_journal && !is_journal_aborted(sbi->s_journal)) {\n\t\t\t(void) ext4_force_commit(sb);\n\t\t\tjbd2_journal_abort(sbi->s_journal, -ESHUTDOWN);\n\t\t}\n\t\tbreak;\n\tcase EXT4_GOING_FLAGS_NOLOGFLUSH:\n\t\tset_bit(EXT4_FLAGS_SHUTDOWN, &sbi->s_ext4_flags);\n\t\tif (sbi->s_journal && !is_journal_aborted(sbi->s_journal))\n\t\t\tjbd2_journal_abort(sbi->s_journal, -ESHUTDOWN);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tclear_opt(sb, DISCARD);\n\treturn 0;\n}\n\nstatic int ext4_ioctl_shutdown(struct super_block *sb, unsigned long arg)\n{\n\tu32 flags;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (get_user(flags, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\treturn ext4_force_shutdown(sb, flags);\n}\n\nstruct getfsmap_info {\n\tstruct super_block\t*gi_sb;\n\tstruct fsmap_head __user *gi_data;\n\tunsigned int\t\tgi_idx;\n\t__u32\t\t\tgi_last_flags;\n};\n\nstatic int ext4_getfsmap_format(struct ext4_fsmap *xfm, void *priv)\n{\n\tstruct getfsmap_info *info = priv;\n\tstruct fsmap fm;\n\n\ttrace_ext4_getfsmap_mapping(info->gi_sb, xfm);\n\n\tinfo->gi_last_flags = xfm->fmr_flags;\n\text4_fsmap_from_internal(info->gi_sb, &fm, xfm);\n\tif (copy_to_user(&info->gi_data->fmh_recs[info->gi_idx++], &fm,\n\t\t\tsizeof(struct fsmap)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ext4_ioc_getfsmap(struct super_block *sb,\n\t\t\t     struct fsmap_head __user *arg)\n{\n\tstruct getfsmap_info info = { NULL };\n\tstruct ext4_fsmap_head xhead = {0};\n\tstruct fsmap_head head;\n\tbool aborted = false;\n\tint error;\n\n\tif (copy_from_user(&head, arg, sizeof(struct fsmap_head)))\n\t\treturn -EFAULT;\n\tif (memchr_inv(head.fmh_reserved, 0, sizeof(head.fmh_reserved)) ||\n\t    memchr_inv(head.fmh_keys[0].fmr_reserved, 0,\n\t\t       sizeof(head.fmh_keys[0].fmr_reserved)) ||\n\t    memchr_inv(head.fmh_keys[1].fmr_reserved, 0,\n\t\t       sizeof(head.fmh_keys[1].fmr_reserved)))\n\t\treturn -EINVAL;\n\t/*\n\t * ext4 doesn\'t report file extents at all, so the only valid\n\t * file offsets are the magic ones (all zeroes or all ones).\n\t */\n\tif (head.fmh_keys[0].fmr_offset ||\n\t    (head.fmh_keys[1].fmr_offset != 0 &&\n\t     head.fmh_keys[1].fmr_offset != -1ULL))\n\t\treturn -EINVAL;\n\n\txhead.fmh_iflags = head.fmh_iflags;\n\txhead.fmh_count = head.fmh_count;\n\text4_fsmap_to_internal(sb, &xhead.fmh_keys[0], &head.fmh_keys[0]);\n\text4_fsmap_to_internal(sb, &xhead.fmh_keys[1], &head.fmh_keys[1]);\n\n\ttrace_ext4_getfsmap_low_key(sb, &xhead.fmh_keys[0]);\n\ttrace_ext4_getfsmap_high_key(sb, &xhead.fmh_keys[1]);\n\n\tinfo.gi_sb = sb;\n\tinfo.gi_data = arg;\n\terror = ext4_getfsmap(sb, &xhead, ext4_getfsmap_format, &info);\n\tif (error == EXT4_QUERY_RANGE_ABORT)\n\t\taborted = true;\n\telse if (error)\n\t\treturn error;\n\n\t/* If we didn\'t abort, set the "last" flag in the last fmx */\n\tif (!aborted && info.gi_idx) {\n\t\tinfo.gi_last_flags |= FMR_OF_LAST;\n\t\tif (copy_to_user(&info.gi_data->fmh_recs[info.gi_idx - 1].fmr_flags,\n\t\t\t\t &info.gi_last_flags,\n\t\t\t\t sizeof(info.gi_last_flags)))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/* copy back header */\n\thead.fmh_entries = xhead.fmh_entries;\n\thead.fmh_oflags = xhead.fmh_oflags;\n\tif (copy_to_user(arg, &head, sizeof(struct fsmap_head)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long ext4_ioctl_group_add(struct file *file,\n\t\t\t\t struct ext4_new_group_data *input)\n{\n\tstruct super_block *sb = file_inode(file)->i_sb;\n\tint err, err2=0;\n\n\terr = ext4_resize_begin(sb);\n\tif (err)\n\t\treturn err;\n\n\tif (ext4_has_feature_bigalloc(sb)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t "Online resizing not supported with bigalloc");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto group_add_out;\n\t}\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto group_add_out;\n\n\terr = ext4_group_add(sb, input);\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal, 0);\n\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t}\n\tif (err == 0)\n\t\terr = err2;\n\tmnt_drop_write_file(file);\n\tif (!err && ext4_has_group_desc_csum(sb) &&\n\t    test_opt(sb, INIT_INODE_TABLE))\n\t\terr = ext4_register_li_request(sb, input->group);\ngroup_add_out:\n\terr2 = ext4_resize_end(sb, false);\n\tif (err == 0)\n\t\terr = err2;\n\treturn err;\n}\n\nint ext4_fileattr_get(struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tu32 flags = ei->i_flags & EXT4_FL_USER_VISIBLE;\n\n\tif (S_ISREG(inode->i_mode))\n\t\tflags &= ~FS_PROJINHERIT_FL;\n\n\tfileattr_fill_flags(fa, flags);\n\tif (ext4_has_feature_project(inode->i_sb))\n\t\tfa->fsx_projid = from_kprojid(&init_user_ns, ei->i_projid);\n\n\treturn 0;\n}\n\nint ext4_fileattr_set(struct mnt_idmap *idmap,\n\t\t      struct dentry *dentry, struct fileattr *fa)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tu32 flags = fa->flags;\n\tint err = -EOPNOTSUPP;\n\n\tif (flags & ~EXT4_FL_USER_VISIBLE)\n\t\tgoto out;\n\n\t/*\n\t * chattr(1) grabs flags via GETFLAGS, modifies the result and\n\t * passes that to SETFLAGS. So we cannot easily make SETFLAGS\n\t * more restrictive than just silently masking off visible but\n\t * not settable flags as we always did.\n\t */\n\tflags &= EXT4_FL_USER_MODIFIABLE;\n\tif (ext4_mask_flags(inode->i_mode, flags) != flags)\n\t\tgoto out;\n\terr = ext4_ioctl_check_immutable(inode, fa->fsx_projid, flags);\n\tif (err)\n\t\tgoto out;\n\terr = ext4_ioctl_setflags(inode, flags);\n\tif (err)\n\t\tgoto out;\n\terr = ext4_ioctl_setproject(inode, fa->fsx_projid);\nout:\n\treturn err;\n}\n\n/* So that the fiemap access checks can\'t overflow on 32 bit machines. */\n#define FIEMAP_MAX_EXTENTS\t(UINT_MAX / sizeof(struct fiemap_extent))\n\nstatic int ext4_ioctl_get_es_cache(struct file *filp, unsigned long arg)\n{\n\tstruct fiemap fiemap;\n\tstruct fiemap __user *ufiemap = (struct fiemap __user *) arg;\n\tstruct fiemap_extent_info fieinfo = { 0, };\n\tstruct inode *inode = file_inode(filp);\n\tint error;\n\n\tif (copy_from_user(&fiemap, ufiemap, sizeof(fiemap)))\n\t\treturn -EFAULT;\n\n\tif (fiemap.fm_extent_count > FIEMAP_MAX_EXTENTS)\n\t\treturn -EINVAL;\n\n\tfieinfo.fi_flags = fiemap.fm_flags;\n\tfieinfo.fi_extents_max = fiemap.fm_extent_count;\n\tfieinfo.fi_extents_start = ufiemap->fm_extents;\n\n\terror = ext4_get_es_cache(inode, &fieinfo, fiemap.fm_start,\n\t\t\tfiemap.fm_length);\n\tfiemap.fm_flags = fieinfo.fi_flags;\n\tfiemap.fm_mapped_extents = fieinfo.fi_extents_mapped;\n\tif (copy_to_user(ufiemap, &fiemap, sizeof(fiemap)))\n\t\terror = -EFAULT;\n\n\treturn error;\n}\n\nstatic int ext4_ioctl_checkpoint(struct file *filp, unsigned long arg)\n{\n\tint err = 0;\n\t__u32 flags = 0;\n\tunsigned int flush_flags = 0;\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (copy_from_user(&flags, (__u32 __user *)arg,\n\t\t\t\tsizeof(__u32)))\n\t\treturn -EFAULT;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* check for invalid bits set */\n\tif ((flags & ~EXT4_IOC_CHECKPOINT_FLAG_VALID) ||\n\t\t\t\t((flags & JBD2_JOURNAL_FLUSH_DISCARD) &&\n\t\t\t\t(flags & JBD2_JOURNAL_FLUSH_ZEROOUT)))\n\t\treturn -EINVAL;\n\n\tif (!EXT4_SB(sb)->s_journal)\n\t\treturn -ENODEV;\n\n\tif ((flags & JBD2_JOURNAL_FLUSH_DISCARD) &&\n\t    !bdev_max_discard_sectors(EXT4_SB(sb)->s_journal->j_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & EXT4_IOC_CHECKPOINT_FLAG_DRY_RUN)\n\t\treturn 0;\n\n\tif (flags & EXT4_IOC_CHECKPOINT_FLAG_DISCARD)\n\t\tflush_flags |= JBD2_JOURNAL_FLUSH_DISCARD;\n\n\tif (flags & EXT4_IOC_CHECKPOINT_FLAG_ZEROOUT) {\n\t\tflush_flags |= JBD2_JOURNAL_FLUSH_ZEROOUT;\n\t\tpr_info_ratelimited("warning: checkpointing journal with EXT4_IOC_CHECKPOINT_FLAG_ZEROOUT can be slow");\n\t}\n\n\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\terr = jbd2_journal_flush(EXT4_SB(sb)->s_journal, flush_flags);\n\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\n\treturn err;\n}\n\nstatic int ext4_ioctl_setlabel(struct file *filp, const char __user *user_label)\n{\n\tsize_t len;\n\tint ret = 0;\n\tchar new_label[EXT4_LABEL_MAX + 1];\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Copy the maximum length allowed for ext4 label with one more to\n\t * find the required terminating null byte in order to test the\n\t * label length. The on disk label doesn\'t need to be null terminated.\n\t */\n\tif (copy_from_user(new_label, user_label, EXT4_LABEL_MAX + 1))\n\t\treturn -EFAULT;\n\n\tlen = strnlen(new_label, EXT4_LABEL_MAX + 1);\n\tif (len > EXT4_LABEL_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Clear the buffer after the new label\n\t */\n\tmemset(new_label + len, 0, EXT4_LABEL_MAX - len);\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_update_superblocks_fn(sb, ext4_sb_setlabel, new_label);\n\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n\nstatic int ext4_ioctl_getlabel(struct ext4_sb_info *sbi, char __user *user_label)\n{\n\tchar label[EXT4_LABEL_MAX + 1];\n\n\t/*\n\t * EXT4_LABEL_MAX must always be smaller than FSLABEL_MAX because\n\t * FSLABEL_MAX must include terminating null byte, while s_volume_name\n\t * does not have to.\n\t */\n\tBUILD_BUG_ON(EXT4_LABEL_MAX >= FSLABEL_MAX);\n\n\tmemset(label, 0, sizeof(label));\n\tlock_buffer(sbi->s_sbh);\n\tstrncpy(label, sbi->s_es->s_volume_name, EXT4_LABEL_MAX);\n\tunlock_buffer(sbi->s_sbh);\n\n\tif (copy_to_user(user_label, label, sizeof(label)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ext4_ioctl_getuuid(struct ext4_sb_info *sbi,\n\t\t\tstruct fsuuid __user *ufsuuid)\n{\n\tstruct fsuuid fsuuid;\n\t__u8 uuid[UUID_SIZE];\n\n\tif (copy_from_user(&fsuuid, ufsuuid, sizeof(fsuuid)))\n\t\treturn -EFAULT;\n\n\tif (fsuuid.fsu_len == 0) {\n\t\tfsuuid.fsu_len = UUID_SIZE;\n\t\tif (copy_to_user(&ufsuuid->fsu_len, &fsuuid.fsu_len,\n\t\t\t\t\tsizeof(fsuuid.fsu_len)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tif (fsuuid.fsu_len < UUID_SIZE || fsuuid.fsu_flags != 0)\n\t\treturn -EINVAL;\n\n\tlock_buffer(sbi->s_sbh);\n\tmemcpy(uuid, sbi->s_es->s_uuid, UUID_SIZE);\n\tunlock_buffer(sbi->s_sbh);\n\n\tfsuuid.fsu_len = UUID_SIZE;\n\tif (copy_to_user(ufsuuid, &fsuuid, sizeof(fsuuid)) ||\n\t    copy_to_user(&ufsuuid->fsu_uuid[0], uuid, UUID_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ext4_ioctl_setuuid(struct file *filp,\n\t\t\tconst struct fsuuid __user *ufsuuid)\n{\n\tint ret = 0;\n\tstruct super_block *sb = file_inode(filp)->i_sb;\n\tstruct fsuuid fsuuid;\n\t__u8 uuid[UUID_SIZE];\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * If any checksums (group descriptors or metadata) are being used\n\t * then the checksum seed feature is required to change the UUID.\n\t */\n\tif (((ext4_has_feature_gdt_csum(sb) || ext4_has_metadata_csum(sb))\n\t\t\t&& !ext4_has_feature_csum_seed(sb))\n\t\t|| ext4_has_feature_stable_inodes(sb))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&fsuuid, ufsuuid, sizeof(fsuuid)))\n\t\treturn -EFAULT;\n\n\tif (fsuuid.fsu_len != UUID_SIZE || fsuuid.fsu_flags != 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(uuid, &ufsuuid->fsu_uuid[0], UUID_SIZE))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ext4_update_superblocks_fn(sb, ext4_sb_setuuid, &uuid);\n\tmnt_drop_write_file(filp);\n\n\treturn ret;\n}\n\nstatic long __ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct mnt_idmap *idmap = file_mnt_idmap(filp);\n\n\text4_debug("cmd = %u, arg = %lu\\n", cmd, arg);\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFSMAP:\n\t\treturn ext4_ioc_getfsmap(sb, (void __user *)arg);\n\tcase EXT4_IOC_GETVERSION:\n\tcase EXT4_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT4_IOC_SETVERSION:\n\tcase EXT4_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext4_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EPERM;\n\n\t\tif (ext4_has_metadata_csum(inode->i_sb)) {\n\t\t\text4_warning(sb, "Setting inode version is not "\n\t\t\t\t     "supported with metadata_csum enabled.");\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tinode_lock(inode);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = current_time(inode);\n\t\t\tinode_inc_iversion(inode);\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text4_journal_stop(handle);\n\nunlock_out:\n\t\tinode_unlock(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT4_IOC_GROUP_EXTEND: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err, err2=0;\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\tif (ext4_has_feature_bigalloc(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Online resizing not supported with bigalloc");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto group_extend_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto group_extend_out;\n\n\t\terr = ext4_group_extend(sb, EXT4_SB(sb)->s_es, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal, 0);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\ngroup_extend_out:\n\t\terr2 = ext4_resize_end(sb, false);\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_MOVE_EXT: {\n\t\tstruct move_extent me;\n\t\tstruct fd donor;\n\t\tint err;\n\n\t\tif (!(filp->f_mode & FMODE_READ) ||\n\t\t    !(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\tif (copy_from_user(&me,\n\t\t\t(struct move_extent __user *)arg, sizeof(me)))\n\t\t\treturn -EFAULT;\n\t\tme.moved_len = 0;\n\n\t\tdonor = fdget(me.donor_fd);\n\t\tif (!donor.file)\n\t\t\treturn -EBADF;\n\n\t\tif (!(donor.file->f_mode & FMODE_WRITE)) {\n\t\t\terr = -EBADF;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\tif (ext4_has_feature_bigalloc(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Online defrag not supported with bigalloc");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto mext_out;\n\t\t} else if (IS_DAX(inode)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t "Online defrag not supported with DAX");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto mext_out;\n\t\t}\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto mext_out;\n\n\t\terr = ext4_move_extents(filp, donor.file, me.orig_start,\n\t\t\t\t\tme.donor_start, me.len, &me.moved_len);\n\t\tmnt_drop_write_file(filp);\n\n\t\tif (copy_to_user((struct move_extent __user *)arg,\n\t\t\t\t &me, sizeof(me)))\n\t\t\terr = -EFAULT;\nmext_out:\n\t\tfdput(donor);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_GROUP_ADD: {\n\t\tstruct ext4_new_group_data input;\n\n\t\tif (copy_from_user(&input, (struct ext4_new_group_input __user *)arg,\n\t\t\t\tsizeof(input)))\n\t\t\treturn -EFAULT;\n\n\t\treturn ext4_ioctl_group_add(filp, &input);\n\t}\n\n\tcase EXT4_IOC_MIGRATE:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * inode_mutex prevent write and truncate on the file.\n\t\t * Read still goes through. We take i_data_sem in\n\t\t * ext4_ext_swap_inode_data before we switch the\n\t\t * inode format to prevent read.\n\t\t */\n\t\tinode_lock((inode));\n\t\terr = ext4_ext_migrate(inode);\n\t\tinode_unlock((inode));\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_ALLOC_DA_BLKS:\n\t{\n\t\tint err;\n\t\tif (!inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EACCES;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_SWAP_BOOT:\n\t{\n\t\tint err;\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = swap_inode_boot_loader(sb, idmap, inode);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\n\tcase EXT4_IOC_RESIZE_FS: {\n\t\text4_fsblk_t n_blocks_count;\n\t\tint err = 0, err2 = 0;\n\t\text4_group_t o_group = EXT4_SB(sb)->s_groups_count;\n\n\t\tif (copy_from_user(&n_blocks_count, (__u64 __user *)arg,\n\t\t\t\t   sizeof(__u64))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\terr = ext4_resize_begin(sb);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\tgoto resizefs_out;\n\n\t\terr = ext4_resize_fs(sb, n_blocks_count);\n\t\tif (EXT4_SB(sb)->s_journal) {\n\t\t\text4_fc_mark_ineligible(sb, EXT4_FC_REASON_RESIZE, NULL);\n\t\t\tjbd2_journal_lock_updates(EXT4_SB(sb)->s_journal);\n\t\t\terr2 = jbd2_journal_flush(EXT4_SB(sb)->s_journal, 0);\n\t\t\tjbd2_journal_unlock_updates(EXT4_SB(sb)->s_journal);\n\t\t}\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\tmnt_drop_write_file(filp);\n\t\tif (!err && (o_group < EXT4_SB(sb)->s_groups_count) &&\n\t\t    ext4_has_group_desc_csum(sb) &&\n\t\t    test_opt(sb, INIT_INODE_TABLE))\n\t\t\terr = ext4_register_li_request(sb, o_group);\n\nresizefs_out:\n\t\terr2 = ext4_resize_end(sb, true);\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t\treturn err;\n\t}\n\n\tcase FITRIM:\n\t{\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!bdev_max_discard_sectors(sb->s_bdev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t/*\n\t\t * We haven\'t replayed the journal, so we cannot use our\n\t\t * block-bitmap-guided storage zapping commands.\n\t\t */\n\t\tif (test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb))\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\tret = ext4_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t    sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\t\treturn ext4_ext_precache(inode);\n\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_set_policy(filp, (const void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_PWSALT:\n\t\treturn ext4_ioctl_get_encryption_pwsalt(filp, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_get_policy(filp, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_get_policy_ex(filp, (void __user *)arg);\n\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_add_key(filp, (void __user *)arg);\n\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_remove_key(filp, (void __user *)arg);\n\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_remove_key_all_users(filp,\n\t\t\t\t\t\t\t  (void __user *)arg);\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_get_key_status(filp, (void __user *)arg);\n\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\t\tif (!ext4_has_feature_encrypt(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fscrypt_ioctl_get_nonce(filp, (void __user *)arg);\n\n\tcase EXT4_IOC_CLEAR_ES_CACHE:\n\t{\n\t\tif (!inode_owner_or_capable(idmap, inode))\n\t\t\treturn -EACCES;\n\t\text4_clear_inode_es(inode);\n\t\treturn 0;\n\t}\n\n\tcase EXT4_IOC_GETSTATE:\n\t{\n\t\t__u32\tstate = 0;\n\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED))\n\t\t\tstate |= EXT4_STATE_FLAG_EXT_PRECACHED;\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\t\tstate |= EXT4_STATE_FLAG_NEW;\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY))\n\t\t\tstate |= EXT4_STATE_FLAG_NEWENTRY;\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE))\n\t\t\tstate |= EXT4_STATE_FLAG_DA_ALLOC_CLOSE;\n\n\t\treturn put_user(state, (__u32 __user *) arg);\n\t}\n\n\tcase EXT4_IOC_GET_ES_CACHE:\n\t\treturn ext4_ioctl_get_es_cache(filp, arg);\n\n\tcase EXT4_IOC_SHUTDOWN:\n\t\treturn ext4_ioctl_shutdown(sb, arg);\n\n\tcase FS_IOC_ENABLE_VERITY:\n\t\tif (!ext4_has_feature_verity(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fsverity_ioctl_enable(filp, (const void __user *)arg);\n\n\tcase FS_IOC_MEASURE_VERITY:\n\t\tif (!ext4_has_feature_verity(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fsverity_ioctl_measure(filp, (void __user *)arg);\n\n\tcase FS_IOC_READ_VERITY_METADATA:\n\t\tif (!ext4_has_feature_verity(sb))\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn fsverity_ioctl_read_metadata(filp,\n\t\t\t\t\t\t    (const void __user *)arg);\n\n\tcase EXT4_IOC_CHECKPOINT:\n\t\treturn ext4_ioctl_checkpoint(filp, arg);\n\n\tcase FS_IOC_GETFSLABEL:\n\t\treturn ext4_ioctl_getlabel(EXT4_SB(sb), (void __user *)arg);\n\n\tcase FS_IOC_SETFSLABEL:\n\t\treturn ext4_ioctl_setlabel(filp,\n\t\t\t\t\t   (const void __user *)arg);\n\n\tcase EXT4_IOC_GETFSUUID:\n\t\treturn ext4_ioctl_getuuid(EXT4_SB(sb), (void __user *)arg);\n\tcase EXT4_IOC_SETFSUUID:\n\t\treturn ext4_ioctl_setuuid(filp, (const void __user *)arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nlong ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\treturn __ext4_ioctl(filp, cmd, arg);\n}\n\n#ifdef CONFIG_COMPAT\nlong ext4_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT4_IOC32_GETVERSION:\n\t\tcmd = EXT4_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT4_IOC32_SETVERSION:\n\t\tcmd = EXT4_IOC_SETVERSION;\n\t\tbreak;\n\tcase EXT4_IOC32_GROUP_EXTEND:\n\t\tcmd = EXT4_IOC_GROUP_EXTEND;\n\t\tbreak;\n\tcase EXT4_IOC32_GETVERSION_OLD:\n\t\tcmd = EXT4_IOC_GETVERSION_OLD;\n\t\tbreak;\n\tcase EXT4_IOC32_SETVERSION_OLD:\n\t\tcmd = EXT4_IOC_SETVERSION_OLD;\n\t\tbreak;\n\tcase EXT4_IOC32_GETRSVSZ:\n\t\tcmd = EXT4_IOC_GETRSVSZ;\n\t\tbreak;\n\tcase EXT4_IOC32_SETRSVSZ:\n\t\tcmd = EXT4_IOC_SETRSVSZ;\n\t\tbreak;\n\tcase EXT4_IOC32_GROUP_ADD: {\n\t\tstruct compat_ext4_new_group_input __user *uinput;\n\t\tstruct ext4_new_group_data input;\n\t\tint err;\n\n\t\tuinput = compat_ptr(arg);\n\t\terr = get_user(input.group, &uinput->group);\n\t\terr |= get_user(input.block_bitmap, &uinput->block_bitmap);\n\t\terr |= get_user(input.inode_bitmap, &uinput->inode_bitmap);\n\t\terr |= get_user(input.inode_table, &uinput->inode_table);\n\t\terr |= get_user(input.blocks_count, &uinput->blocks_count);\n\t\terr |= get_user(input.reserved_blocks,\n\t\t\t\t&uinput->reserved_blocks);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\treturn ext4_ioctl_group_add(file, &input);\n\t}\n\tcase EXT4_IOC_MOVE_EXT:\n\tcase EXT4_IOC_RESIZE_FS:\n\tcase FITRIM:\n\tcase EXT4_IOC_PRECACHE_EXTENTS:\n\tcase FS_IOC_SET_ENCRYPTION_POLICY:\n\tcase FS_IOC_GET_ENCRYPTION_PWSALT:\n\tcase FS_IOC_GET_ENCRYPTION_POLICY:\n\tcase FS_IOC_GET_ENCRYPTION_POLICY_EX:\n\tcase FS_IOC_ADD_ENCRYPTION_KEY:\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY:\n\tcase FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS:\n\tcase FS_IOC_GET_ENCRYPTION_KEY_STATUS:\n\tcase FS_IOC_GET_ENCRYPTION_NONCE:\n\tcase EXT4_IOC_SHUTDOWN:\n\tcase FS_IOC_GETFSMAP:\n\tcase FS_IOC_ENABLE_VERITY:\n\tcase FS_IOC_MEASURE_VERITY:\n\tcase FS_IOC_READ_VERITY_METADATA:\n\tcase EXT4_IOC_CLEAR_ES_CACHE:\n\tcase EXT4_IOC_GETSTATE:\n\tcase EXT4_IOC_GET_ES_CACHE:\n\tcase EXT4_IOC_CHECKPOINT:\n\tcase FS_IOC_GETFSLABEL:\n\tcase FS_IOC_SETFSLABEL:\n\tcase EXT4_IOC_GETFSUUID:\n\tcase EXT4_IOC_SETFSUUID:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext4_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}\n#endif\n\nstatic void set_overhead(struct ext4_super_block *es, const void *arg)\n{\n\tes->s_overhead_clusters = cpu_to_le32(*((unsigned long *) arg));\n}\n\nint ext4_update_overhead(struct super_block *sb, bool force)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\tif (!force &&\n\t    (sbi->s_overhead == 0 ||\n\t     sbi->s_overhead == le32_to_cpu(sbi->s_es->s_overhead_clusters)))\n\t\treturn 0;\n\treturn ext4_update_superblocks_fn(sb, set_overhead, &sbi->s_overhead);\n}\n'
"""

if __name__ == '__main__':
    gpt35_azure_llm = AzureChatOpenAI(
        temperature=0,
        openai_api_key="02e3dbabaf334ccb959cbeadbd3f99c3",
        openai_api_base="https://llm-x-gpt.openai.azure.com/",
        deployment_name='LLM-X-GPT35-TURBO',
        openai_api_version="2023-03-15-preview"
    )

    multi_qa_prompt = PromptTemplate.from_template(template=MULTI_QA_GPT35_PROMPT_TEMPLATE,
                                                   partial_variables={"k": 2})
    qa_generation_chain = QAGenerationChain.from_llm(llm=gpt35_azure_llm,
                                                     prompt=multi_qa_prompt)

    a = qa_generation_chain.run(DOC[:12000])
    breakpoint()

